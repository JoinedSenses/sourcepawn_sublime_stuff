%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions:
  - sp
  - inc
scope: source.sp

variables:
  numerals_binary: '\b0b[01]+\b'
  numerals_hex: '\b0x[0-9a-fA-F]{0,8}\b'
  numerals_intfloat: '\b\d+(\.\d*)?(e-?\d*)?\b'
  numerals: '{{numerals_binary}}|{{numerals_hex}}|{{numerals_intfloat}}'

  identifier: '(?:[[:alpha:]_]\w*)'
  deprecated_identifier: '\b{{identifier}}:'
  casts: 'view_as'
  modifier_decl: 'public[ \t]+native|stock|native|forward|static'
  operator_method_name: '\boperator\s*[-+*/%^&|~!=<>]|[-+*/%^&|=!<>]=|<<=?|>>=?|&&|\|\||\+\+|--|,|->\*?|\(\)|\[\]'
  control_keywords: 'break|case|continue|default|do|else|for|if|return|switch|while'
  memory_operators: 'new|delete'
  basic_types: 'any|bool|char|float|int|void'
  before_tag: 'enum|enum\s+struct|methodmap|struct'
  storage_classes: 'static|native|forward|public|stock|function'
  type_qualifier: 'const'
  directives: 'include|pragma|define|error|if|file|endif|endinput'
  pragmas: 'ctrlchar|dynamic|newdecls|rational|semicolon|tabsize|unused'
  pragma_derecated: 'deprecated'
  pragma_newdecls: 'required|optional'
  end_of_line: '(?<!\\)(\\\\)*$(?=\n)'
  str_format_char: '%[!\-\d\.]*[%bcdfiLNstTuxX]?'
  const_char_escape: \\(?:[abefnrt'"%\\]|(?:x[a-zA-Z0-9]{0,2}|\d+);?)

contexts:
  main:
    - include: preprocessor-global
    - include: global



  preprocessor-global:
    - include: preprocessor-rule-enabled-global

  global:

    - include: preprocessor-expressions
    - include: constants
    - include: typedef_set
    - include: strings
    - include: comments
    - include: keywords
    - include: types
    - include: functions
  #   - include: paren_test

  # paren_test:
  #   - match: \(
  #     push:
  #       - meta_scope: meta.group.sp
  #       - include: paren_test
  #       - match: \)
  #         pop: true


  keywords:
    - match: \bbreak\b
      scope: keyword.control.flow.break.sp
    - match: \bcontinue\b
      scope: keyword.control.flow.continue.sp
    - match: \breturn\b
      scope: keyword.control.flow.return.sp
    - match: '\b({{control_keywords}})\b'
      scope: keyword.control.sp
    - match: '\b(?:sizeof|cellsof|tagof)\b'
      scope: keyword.operator.word.sp

  expressions:
    - include: early-expressions
    - include: late-expressions

  early-expressions:
    - include: preprocessor-expressions
    - include: comments
    - include: parens

  late-expressions:
    - include: types

  preprocessor-expressions:
    - include: preprocessor-macro-define
    - include: pragma
    - include: preprocessor-other

  preprocessor-macro-define:
    - match: '^\s*(?:#(\s*)(define))\b\s*?'
      captures:
        1: invalid.illegal.sp
        2: keyword.control.define.sp
      push:
        - meta_scope: meta.preprocessor.define.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: '{{end_of_line}}'
          pop: true

        - match: '(([^[:alpha:]_\(\s])?\S+?)(?=\()'
          captures:
            1: entity.name.function.sp
            2: invalid.illegal.sp
          set:
            - match: '\('
              scope: punctuation.section.group.begin.sp
              set: preprocessor-macro-params
            - match: '{{end_of_line}}'
              pop: true


        # - match: '(([^[:alpha:]_\(\s])\S*?|\S+)'
        - match: '(([^[:alpha:]_\(\s])?\S+)(?=\s)'
          captures:
            1: entity.name.constant.sp
            2: invalid.illegal.sp
          push:
            # - meta_scope: meta.preprocessor.sp
            - include: preprocessor-line-continuation
            - include: preprocessor-comments
            - include: strings
            - include: constants
            - match: '{{end_of_line}}'
              pop: true


  preprocessor-macro-params:
    - meta_scope: meta.preprocessor.macro.parameters.sp meta.group.sp
    - match: '%\d+'
      scope: variable.parameter.sp
    - match: \)
      scope: punctuation.section.group.end.sp
      set: preprocessor-macro-definition


  preprocessor-macro-definition:
    - meta_content_scope: meta.preprocessor.macro.sp
    - include: preprocessor-line-continuation
    - include: preprocessor-comments
    - match: '{{end_of_line}}'
      pop: true

  preprocessor-line-continuation:
    - match: '(?<!\\)(?:\\\\)*\K(\\)$(?=\n)'
      scope: punctuation.separator.continuation.sp
    - match: '(?<!\\)(?:\\\\)*\K(\\)([ \t]+?)$'
      captures:
        1: punctuation.separator.continuation.sp
        2: invalid.illegal.space-after-continuation.sp

  preprocessor-comments:
    - match: (?<!\\)(\\\\)*\K\/\*
      scope: punctuation.definition.comment.begin.sp
      push:
        - meta_scope: comment.block.sp
        - match: \*\/
          scope: punctuation.definition.comment.end.sp
          pop: true
    - match: \/\/
      scope: punctuation.definition.comment.sp
      push:
        - meta_scope: comment.line.double-slash.sp
        - match: (?<!\\)(?:\\\\)*\K(\\)$(?=\n)
          scope: punctuation.separator.continuation.sp
        - match: '{{end_of_line}}'
          pop: true

  pragma:
    - match: '^[ \t]*(#)(\s*)(pragma)\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.sp
        3: keyword.control.pragma.sp
      push:
        - meta_scope: meta.preprocessor.pragma.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

        - match: '{{end_of_line}}'
          pop: true

        - match: '(dynamic|semicolon|tabsize)([ \t]+\d*)?'
          captures:
            1: keyword.control.sp
            2: constant.numeric.integer.sp
          set: preprocessor_eol

        - match: (ctrlchar)([ \t]+(\')(?:([^\\'])|({{const_char_escape}}))?('))?
          captures:
            1: keyword.control.sp
            2: constant.character.escape.sp
            3: punctuation.definition.string.begin.sp
            4: constant.character.sp
            5: constant.character.escape.sp
            6: punctuation.definition.string.end.sp
          set: preprocessor_eol

        - match: '(unused)([ \t]+{{identifier}})?'
          captures:
            1: keyword.control.sp
            2: variable.other.sp
          set: preprocessor_eol

        - match: 'rational'
          scope: keyword.control.sp
          set: preprocessor_eol

        - match: '(newdecls(?:[ \t]+(?:required|optional)\b(?:$|[^\S]))?)'
          scope: keyword.control.sp
          set: preprocessor_eol

        - match: 'deprecated'
          scope: keyword.control.sp invalid.deprecated.sp
          set:
          - meta_content_scope: meta.preprocessor.pragma.deprecated.sp
          - match: '{{end_of_line}}'
            pop: true

        - match: \S
          push:
          - clear_scopes: true
          - match: '{{end_of_line}}'
            pop: true


  preprocessor_eol:
    - match: '{{end_of_line}}'
      pop: true
    - include: preprocessor-line-continuation
    - include: preprocessor-comments


  preprocessor-other:
    - match: '^[ \t]*(#(\s*)((?:else)?if))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.sp
        3: keyword.control.import.if.sp
      push:
        - meta_scope: meta.preprocessor.conditional.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: \bdefined\b
          scope: keyword.control.import.define.sp
          push:
            - match: '{{identifier}}'
              scope: variable.other.constant.sp
              pop: true
        - match: '{{end_of_line}}'
          pop: true
    - match: '^[ \t]*(#(\s*)(undef))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.sp
        3: keyword.control.import.undef.sp
      push:
        - meta_scope: meta.preprocessor.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: '{{identifier}}'
          scope: variable.other.constant.sp
          push:
            - include: preprocessor-line-continuation
            - include: preprocessor-comments
            - match: \S+
              scope: invalid.illegal.sp
            - match: '{{end_of_line}}'
              pop: true
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(?:#(\s*)(endif|endinput|else))\b'
      captures:
        1: invalid.illegal.sp
        2: keyword.control.import.if.sp
      push:
        - meta_scope: meta.preprocessor.conditional.sp
        - include: preprocessor-line-continuation
        - include: comments
        - match: (\S+?)(?=$|\/\*|\/\/|\b|\s)
          captures:
            1: invalid.illegal.sp
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(#(\s*)(error))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.sp
        3: keyword.control.import.error.sp
      push:
        - meta_scope: meta.preprocessor.diagnostic.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - include: strings
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(#(\s*)((?:try)?include))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.sp
        3: keyword.control.import.include.sp
      push:
        - meta_scope: meta.preprocessor.sp
        - match: '{{end_of_line}}'
          pop: true
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

        - match: (?<!\\)(\\\\)*\K\"
          scope: punctuation.definition.string.begin.sp
          push:
            - meta_scope: string.quoted.double.include.sp
            - match: (?:({{const_char_escape}})|(\\.))
              captures:
                1: constant.character.escape.sp
                2: invalid.illegal.sp
            - match: (?<!\\)(\\\\)*\K\"
              scope: punctuation.definition.string.end.sp
              pop: true

        - match: '<'
          scope: punctuation.definition.string.begin.sp
          push:
            - meta_scope: string.quoted.other.lt-gt.include.sp
            - match: '>'
              scope: punctuation.definition.string.end.sp
              pop: true

        - match: \S+
          set: preprocessor_eol


    - match: '^[ \t]*(#)'
      captures:
        1: meta.preprocessor.sp
      push:
        - meta_scope: meta.sp
        - match: '{{end_of_line}}'
          pop: true
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

  typedef_set:
    - match: \btypedef\b
      scope: keyword.declaration.function.sp
      push:
      - match: $(?=\n)
        pop: true
      - match: '(?:[ \t]+\b([^[:alpha:]_]+)?({{identifier}})(?:[ \t]*(=)(?:[ \t]*(function)(?:[ \t]+({{identifier}})[ \t]*)?)?)?)?'
        captures:
          1: invalid.illegal.sp
          2: entity.name.type
          3: keyword.operator.assignment.sp
          4: storage.modifier.sp
          5: storage.type.sp
      - include: parens



  parens:
    - match: \(
      scope: punctuation.section.group.begin.sp
      push:
        - meta_scope: meta.group.sp
        - match: \)
          scope: punctuation.section.group.end.sp
          pop: true
        - include: expressions


  types:
    - match: '\b({{basic_types}})\b'
      scope: support.type.sp
    - match: '\bHandle\b'
      scope: storage.type.enum.sp
    - match: '{{identifier}}:[^:]'
      scope: invalid.deprecated.sp


  # https://github.com/alliedmodders/sourcepawn/blob/d919ffc892fb2c908990bd2307e79893bde220a9/compiler/parser.cpp#L1005
  constants:
    - match: '\b(true|false|null|EOS|INVALID_FUNCTION|cellmax|cellmin)\b'
      captures:
        1: constant.language.sp
    - match: \b(__LINE__|__Pawn|debug)\b
      captures:
        1: support.constant.sp
    - match: '{{numerals}}'
      scope: constant.numeric.sp
    - match: '\b[A-Z_][A-Z_\d]+\b'
      scope: variable.constant.sp

  strings:
    - include: const_char

    - match: (?<!\\)(\\\\)*\K\"
      scope: punctuation.definition.string.begin.sp
      set:
        - meta_scope: string.quoted.double.sp
        - match: (?<!\\)(\\\\)*\K\"
          scope: punctuation.definition.string.end.sp
          pop: true
        - match: '{{str_format_char}}'
          scope: constant.other.placeholder.sp
        - match: (?:({{const_char_escape}})|(\\.))
          captures:
            1: constant.character.escape.sp
            2: invalid.illegal.sp

  const_char:
    - match: (?<!\\)(?:\\\\)*\K(\')(?:([^\\'])|({{const_char_escape}}))?(')
      captures:
        1: punctuation.definition.string.begin.sp
        2: constant.character.sp
        3: constant.character.escape.sp
        4: punctuation.definition.string.end.sp

    - match: (?<!\\)(?:\\{2})*\K(\')([^']+|')?
      captures:
        1: punctuation.definition.string.begin.sp
        2: invalid.illegal.sp
      set:
        - meta_scope: string.quoted.single.sp
        - match: (?<!\\)(?:\\{2})*\K\'
          scope: punctuation.definition.string.end.sp
          pop: true


  comments:
    - match: (?<!\\)(\\\\)*\K\/\*
      captures:
        0: punctuation.definition.comment.begin.sp
      push:
        - meta_scope: comment.block.sp
        - match: \*\/
          captures:
            0: punctuation.definition.comment.end.sp
          pop: true
        - match: (@(?:return|noreturn|note|section|endsection|error))
          scope: keyword
        - match: (@param)(?:\s+)([A-Za-z_@.][A-Za-z0-9_@.]*+|...)
          captures:
            1: keyword.operator
            2: variable.parameter
        - match: (@deprecated.*?)[ \t]*(\*\/|$)
          captures:
            1: invalid.deprecated
            2: punctuation.definition.comment

    - match: '\/\/'
      scope: puncutation.definition.comment
      push:
        - meta_scope: comment
        - match: (?<!\\)(?:\\\\)*\K(\\)$(?=\n)
          scope: punctuation.separator.continuation.sp
        - match: '{{end_of_line}}'
          pop: true
        - match: \@(?:return|noreturn|note|section|endsection|error)
          scope: keyword
        - match: (@param)\s+([A-Za-z_@.][A-Za-z0-9_@.]*+|...)
          captures:
            1: keyword.operator
            2: variable.parameter
        - match: (@deprecated).*[ \t]*$
          scope: invalid.deprecated

  # should be near the end?
  functions:
    - match: '^[ \t]*(?:({{modifier_decl}})[ \t]+)?(?:({{deprecated_identifier}})|({{identifier}}))(?<!{{control_keywords}}|public)[ \t]+({{identifier}})[ \t]*(?=\()'
      captures:
        1: storage.modifier.sp
        2: invalid.deprecated.sp
        3: storage.type.sp
        4: entity.name.function.sp

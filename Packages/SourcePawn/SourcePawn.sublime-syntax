%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html
name: SourcePawn
file_extensions:
  - sp
  - inc
scope: source.sp

variables:
  numerals_binary: '\b0b[01]+\b'
  numerals_hex: '\b0x[0-9a-fA-F]{0,8}\b'
  numerals_intfloat: '\d+(\.\d*)?(e-?\d*)?\b'
  numerals: '{{numerals_binary}}|{{numerals_hex}}|{{numerals_intfloat}}'

  identifier: '(?:[[:alpha:]_]\w*)'
  # deprecated_identifier: '\b{{identifier}}:'
  # casts: 'view_as'
  modifier_decl: 'public[ \t]+native|stock|native|forward|static'
  # operator_method_name: '\boperator\s*[-+*/%^&|~!=<>]|[-+*/%^&|=!<>]=|<<=?|>>=?|&&|\|\||\+\+|--|,|->\*?|\(\)|\[\]'
  control_keywords: 'break|case|continue|default|do|else|for|if|return|switch|while'
  # memory_operators: 'new|delete'
  basic_types: 'any|bool|char|float|int|void'
  # before_tag: 'enum|enum\s+struct|methodmap|struct'
  # storage_classes: 'static|native|forward|public|stock|function'
  # type_qualifier: 'const'
  # directives: 'include|pragma|define|error|if|file|endif|endinput'
  # pragmas: 'ctrlchar|dynamic|newdecls|rational|semicolon|tabsize|unused'
  # pragma_derecated: 'deprecated'
  # pragma_newdecls: 'required|optional'
  end_of_line: '(?<!\\)(\\\\)*\K$(?=\n)'
  str_format_char: '%[!\-\d\.]*[%bcdfiLNstTuxX]?'
  const_char_escape: \\(?:[abefnrt'"%\\]|(?:x[a-zA-Z0-9]{0,2}|\d+);?)
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------
contexts:
  main:
    - include: global

  global:
    - include: early-expressions
    - include: data-types

  expressions:
    - include: early-expressions

  early-expressions:
    - include: preprocessor
    - include: comments_documentation
    - include: expressions-simple


  expressions-simple:
    - include: comments
    - include: constants
    - include: strings
    - include: view_as
    - include: case-default
    - include: operators
    - include: unique-keywords
    - include: parens
    - include: brackets
    - include: braces

  preprocessor:
    - include: preprocessor-macro-define
    - include: preprocessor-pragma
    - include: preprocessor-other

  preprocessor-macro-define:
    - match: '^\s*(?:#(\s*)(define))\b\s*?'
      captures:
        1: invalid.illegal.unexpected-space.sp
        2: keyword.control.define.spf
      push:
        - meta_scope: meta.preprocessor.define.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: '{{end_of_line}}'
          pop: true

        - match: '(([^[:alpha:]_\(\s])?\S+?)(?=\()'
          captures:
            1: entity.name.function.sp
            2: invalid.illegal.invalid-character.sp
          set:
            - match: '\('
              scope: punctuation.section.group.begin.sp
              set: preprocessor-macro-params
            - match: '{{end_of_line}}'
              pop: true

        - match: '(([^[:alpha:]_\(\s])?\S+)(?=\s)'
          captures:
            1: entity.name.constant.sp
            2: invalid.illegal.invalid-character.sp
          set:
            - include: preprocessor-line-continuation
            - include: preprocessor-comments
            - include: expressions-simple
            - match: '{{end_of_line}}'
              pop: true


  preprocessor-macro-params:
    - meta_scope: meta.preprocessor.macro.parameters.sp meta.group.sp
    - include: preprocessor-comments
    - include: preprocessor-line-continuation
    - match: '%\d+'
      scope: variable.parameter.sp
    - match: \)
      scope: punctuation.section.group.end.sp
      set: preprocessor-macro-definition
    - match: ','
      scope: punctuation.separator.sp
      push:
      - include: preprocessor-comments
      - include: preprocessor-line-continuation
      - match: '%\d+'
        scope: variable.parameter.sp
        pop: true
      - match: '(?=\))'
        pop: true
      - match: '\S+'
        scope: invalid.illegal.unexpected-character.sp

  preprocessor-macro-definition:
    - meta_content_scope: meta.preprocessor.macro.sp
    - include: preprocessor-line-continuation
    - include: preprocessor-comments
    - match: '{{end_of_line}}'
      pop: true
    - include: preprocessor-expressions


  preprocessor-expressions:
    - match: '{{end_of_line}}'
      pop: true

    - match: '%\d+'
      scope: variable.other.readwrite.sp
    - match: \(
      scope: punctuation.section.group.begin.sp
      push:
        - meta_scope: meta.group.sp
        - match: \)
          scope: punctuation.section.group.end.sp
          pop: true

        - include: preprocessor-expressions
    - match: \{
      scope: punctuation.section.braces.begin.sp
      push:
        - meta_scope: meta.block.sp
        - match: \}
          scope: punctuation.section.braces.end.sp
          pop: true

        - include: preprocessor-expressions
    - match: \[
      scope: punctuation.section.brackets.begin.sp
      push:
        - meta_scope: meta.brackets.sp
        - match: \}
          scope: punctuation.section.brackets.end.sp
          pop: true

        - include: preprocessor-expressions
    - include: expressions

  preprocessor-line-continuation:
    - match: '(?<!\\)(?:\\\\)*\K(\\)$(?=\n)'
      scope: punctuation.separator.continuation.sp
    - match: '(?<!\\)(?:\\\\)*\K(\\)([ \t]+?)$'
      captures:
        1: punctuation.separator.continuation.sp
        2: invalid.illegal.space-after-continuation.sp

  preprocessor-comments:
    - match: (?<!\\)(\\\\)*\K\/\*
      scope: punctuation.definition.comment.begin.sp
      push:
        - meta_scope: comment.block.sp
        - match: \*\/
          scope: punctuation.definition.comment.end.sp
          pop: true
    - match: \/\/
      scope: punctuation.definition.comment.sp
      push:
        - meta_scope: comment.line.double-slash.sp
        - match: (?<!\\)(?:\\\\)*\K(\\)$(?=\n)
          scope: punctuation.separator.continuation.sp
        - match: '{{end_of_line}}'
          pop: true

  preprocessor-pragma:
    - match: '^[ \t]*(#)(\s*)(pragma)\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.unexpected-space.sp
        3: keyword.control.pragma.sp
      push:
        - meta_scope: meta.preprocessor.pragma.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

        - match: '{{end_of_line}}'
          pop: true

        - match: '\b(dynamic|semicolon|tabsize)([ \t]+\d*)?'
          captures:
            1: keyword.control.sp
            2: constant.numeric.integer.sp
          set: preprocessor_eol

        - match: \b(ctrlchar)([ \t]+(\')(?:([^\\'])|({{const_char_escape}}))?('))?
          captures:
            1: keyword.control.sp
            2: constant.character.escape.sp
            3: punctuation.definition.string.begin.sp
            4: constant.character.sp
            5: constant.character.escape.sp
            6: punctuation.definition.string.end.sp
          set: preprocessor_eol

        - match: '\b(unused)([ \t]+{{identifier}}\b)?'
          captures:
            1: keyword.control.sp
            2: variable.other.sp
          set: preprocessor_eol

        - match: '\brational\b'
          scope: keyword.control.sp
          set: preprocessor_eol

        - match: '\b(newdecls(?:[ \t]+(?:required|optional)\b(?:$|[^\S]))?)'
          scope: keyword.control.sp
          set: preprocessor_eol

        - match: '\bdeprecated\b'
          scope: keyword.control.sp invalid.deprecated.sp
          set:
          - meta_content_scope: meta.preprocessor.pragma.deprecated.sp
          - match: '{{end_of_line}}'
            pop: true

        - match: \S
          push:
          - clear_scopes: true
          - match: '{{end_of_line}}'
            pop: true

  preprocessor_eol:
    - match: '{{end_of_line}}'
      pop: true
    - include: preprocessor-line-continuation
    - include: preprocessor-comments

  preprocessor-other:
    - match: '^[ \t]*(#(\s*)((?:else)?if))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.unexpected-space.sp
        3: keyword.control.import.if.sp
      push:
        - meta_scope: meta.preprocessor.conditional.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: \bdefined\b
          scope: keyword.control.import.define.sp
          push:
            - match: '\b{{identifier}}\b'
              scope: variable.other.constant.sp
              pop: true
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(#(\s*)(undef))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.unexpected-space.sp
        3: keyword.control.import.undef.sp
      push:
        - meta_scope: meta.preprocessor.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - match: '\b{{identifier}}\b'
          scope: variable.other.constant.sp
          push:
            - include: preprocessor-line-continuation
            - include: preprocessor-comments
            - match: \S+
              scope: invalid.illegal.unexpected-character.sp
            - match: '{{end_of_line}}'
              pop: true
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(?:#(\s*)(endif|endinput|else))\b'
      captures:
        1: invalid.illegal.unexpected-space.sp
        2: keyword.control.import.if.sp
      push:
        - meta_scope: meta.preprocessor.conditional.sp
        - include: preprocessor-line-continuation
        - include: comments
        - match: (\S+?)(?=$|\/\*|\/\/|\b|\s)
          captures:
            1: invalid.illegal.unexpected-character.sp
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(#(\s*)(error))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.unexpected-space.sp
        3: keyword.control.import.error.sp
      push:
        - meta_scope: meta.preprocessor.diagnostic.sp
        - include: preprocessor-line-continuation
        - include: preprocessor-comments
        - include: strings
        - match: '{{end_of_line}}'
          pop: true

    - match: '^[ \t]*(#(\s*)((?:try)?include))\b'
      captures:
        1: meta.preprocessor.sp
        2: invalid.illegal.unexpected-space.sp
        3: keyword.control.import.include.sp
      push:
        - meta_scope: meta.preprocessor.sp
        - match: '{{end_of_line}}'
          pop: true
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

        - match: (?<!\\)(\\\\)*\K\"
          scope: punctuation.definition.string.begin.sp
          set:
            - meta_scope: string.quoted.double.include.sp
            - match: (?:({{const_char_escape}})|(\\.))
              captures:
                1: constant.character.escape.sp
                2: invalid.illegal.unexpected-character.sp
            - match: (?<!\\)(\\\\)*\K\"
              scope: punctuation.definition.string.end.sp
              set: preprocessor_eol

        - match: '<'
          scope: punctuation.definition.string.begin.sp
          set:
            - meta_scope: string.quoted.other.lt-gt.include.sp
            - match: '>'
              scope: punctuation.definition.string.end.sp
              set: preprocessor_eol

        - match: (?=\S)
          set: preprocessor_eol

    - match: '^[ \t]*(#)'
      captures:
        1: meta.preprocessor.sp
      push:
        - match: '{{end_of_line}}'
          pop: true
        - include: preprocessor-line-continuation
        - include: preprocessor-comments

  data-types:
    - include: enum
    - include: methodmap
    - include: typedef
    - include: typeset

  enum:
    - match: '\benum\b'
      scope: storage.modifier.sp
      branch_point: enum_begin
      branch:
        - enum_definition
        - enum_end

  enum_end:
    - match: (?=\S)
      pop: true

  enum_definition:
    - include: comments

    - match: (?=\{)
      set: enum_contents

    - match: \bstruct\b
      scope: storage.modifier.sp
      branch_point: enum_struct_begin
      branch:
      - enum_struct_type
      - enum_end

    - match: \(
      scope: punctuation.section.group.begin.sp
      push:
        - include: enum_increment

        - match: \)
          scope: punctuation.section.group.end.sp
          set:
            - match: (?=\{)
              set: enum_contents
            - match: (?=\S)
              fail: enum_begin

    - match: (?:\b({{identifier}})\s*(:)\s*)?\b({{identifier}}\b(?:\s*(:))?)
      captures:
        1: storage.type.sp
        2: punctuation.separator.sp
        3: entity.name.enum.sp
        4: punctuation.separator.sp
      push:
        - include: comments
        - match: (?=\{)
          set: enum_contents
        - match: (?=\S)
          fail: enum_begin

  enum_struct_type:
    - include: comments
    - match: '\b(?:{{identifier}})\b'
      scope: entity.name.struct.enum.sp
      set:
        - match: \{
          scope: punctuation.section.braces.begin.sp
          set: enum_struct_contents
        - match: (?=\S)
          fail: enum_struct_begin

  enum_increment:
    - meta_content_scope: meta.group.enumincrement.sp

    - match: '(?:[\+\-\*\/]|\<\<|\>\>)\s*='
      scope: keyword.operator.assignment.augmented.sp
      push:
        - match: (?=\))
          pop: true
        - match: \d+
          scope: constant.numeric.integer.sp
          set:
            - match: (?=\))
              pop: true
            - match: '[^\s\)]+'
              scope: invalid.illegal.unexpected-character.sp
        - match: '[^\s\)]+'
          scope: invalid.illegal.unexpected-character.sp

    - match: '([\+\-\*\/]|<<?|>>?)'
      scope: keyword.operator.arithmetic.sp
      push:
        - match: (?=\)|=)
          pop: true
        - match: '[^\s\)]+'
          scope: invalid.illegal.unexpected-character.sp

    - match: '[^\s\)]+'
      scope: invalid.illegal.unexpected-character.sp

  enum_contents:
    - match: \{
      scope: punctuation.section.braces.begin.sp
      branch_point: enum_contents_begin
      branch:
        - enum_normal_contents
        - enum_oldstruct_contents

  enum_normal_contents:
    - meta_scope: meta.enum.sp meta.block.sp
    - match: '\}'
      scope: punctuation.section.braces.end.sp
      pop: 3

    - include: comments
    - include: preprocessor

    - match: '\b(?:{{identifier}})\b\s*:'
      fail: enum_contents_begin

    - match: ','
      scope: punctuation.separator.sp

    - match: '\b(?:{{identifier}})\b'
      scope: entity.name.constant.enum.sp
      push:
        - include: comment

        - match: (?=,|\})
          pop: true

        - match: '='
          scope: keyword.operator.assignment.sp
          push:
            - match: (?=,|\})
              pop: 2

            - include: expressions

        - match: (?=\[)
          fail: enum_contents_begin

        - match: \s+(?=[[:alpha:]_])
          scope: invalid.illegal.missing-comma.sp
          pop: true

        - match: '[^\s,\}]+'
          scope: invalid.illegal.syntax.sp

    - match: '[^\s,\}]+'
      scope: invalid.illegal.syntax.sp

  enum_oldstruct_contents:
    - meta_scope: meta.enumstruct.legacy.sp meta.block.sp
    - match: '\}'
      scope: punctuation.section.braces.end.sp
      pop: 3

    - include: comments_documentation
    - include: preprocessor

    - match: ','
      scope: punctuation.separator.sp

    - match: '\b({{identifier}})\s*(:)'
      captures:
        1: storage.type.sp
        2: punctuation.separator.sp
      push: enum_oldstruct_variables

    - match: (?=[[:alpha:]_])
      push: enum_oldstruct_variables

    - match: '[^\s\}]+'
      scope: invalid.illegal.syntax.sp

  enum_oldstruct_variables:
    - match: '(?=,|\})'
      pop: true

    - match: '\b(?:{{identifier}})\b'
      scope: variable.other.member.sp
      set:
        - include: comments
        - match: ','
          scope: punctuation.separator.sp
          pop: true
        - match: (?=\})
          pop: true
        - match: (?=\[)
          push:
            - include: brackets
            - match: (?=\S)
              pop: true

        - match: \s+(?=[[:alpha:]_])
          scope: invalid.illegal.missing-comma.sp
          pop: true

        - match: \S+
          scope: invalid.illegal.syntax.sp

    - match: (?=\S)
      pop: true

  enum_struct_contents:
    - meta_scope: meta.enumstruct.sp meta.block.sp
    - match: '\}'
      scope: punctuation.section.braces.end.sp
      pop: 2

    - match: ';'
      scope: punctuation.terminator.sp

    - match: '^\s*((?:(?:public|static|const)\s+)*)({{identifier}})\b'
      captures:
        1: invalid.illegal.syntax.sp
        2: storage.type.sp
      branch_point: enum_struct_variable_begin
      branch:
        - enum_struct_variable
        - enum_struct_function
        - enum_struct_variable_end

    - match: '^\s*(const|static|public)\b'
      captures:
        1: invalid.illegal.syntax.sp

  enum_struct_variable:
    - match: '\['
      push:
        - meta_scope: invalid.illegal.syntax.sp
        - match: \]
          pop: true

    - match: (?=\})
      pop: true

    - match: '^\s*(?={{identifier}}\s+[[:alpha:]_\s])|[^[:alpha:]_\s]'
      fail: enum_struct_variable_begin

    - match: '\b(?:{{identifier}})\b'
      scope: variable.other.member.sp
      push:
        - include: comments
        - match: (?=\})
          pop: 2

        - match: (?=\()
          fail: enum_struct_variable_begin

        - match: (?=\[)
          push:
            - include: brackets
            - match: (?=\S)
              pop: true

        - match: ';'
          scope: punctuation.terminator.sp
          pop: 2

        - match: '[^[:alpha:]_\s;]+'
          scope: invalid.illegal.unexpected-character.sp

        - match: '{{end_of_line}}'
          pop: 2

  enum_struct_function:
    - match: '\b(?:{{identifier}})\b'
      scope: entity.name.function.sp
      push:
        - match: \(
          scope: meta.function.parameters.sp punctuation.section.group.begin.sp
          set:
            - match: \)
              scope: punctuation.section.group.end.sp
              set:
                - include: comments
                - match: (?=\{)
                  set: function-definition-body-datatypes
                - match: (?=\S)
                  pop: true

            - include: function-params

        - match: (?=\S)
          fail: enum_struct_variable_begin
          # pop: 2

  function-definition-body-datatypes:
    - meta_content_scope: meta.function.sp
    - match: '\{'
      scope: meta.block.sp punctuation.section.block.begin.sp
      set:
        - meta_content_scope: meta.function.sp meta.block.sp
        - match: '\}'
          scope: meta.function.c meta.block.c punctuation.section.block.end.sp
          pop: 2

        - include: expressions

  enum_struct_variable_end:
    - match: '.*?'
      scope: invalid.illegal.syntax.sp
      pop: true

  methodmap:
    - match: '\bmethodmap\b'
      scope: storage.modifier.sp

  typedef:
    - match: \b(typedef)\b
      scope: keyword.declaration.sp
      branch_point: typedef_begin
      branch:
        - typedef_type
        - typedef_end

  typedef_type:
    - include: comments

    - match: '\b({{identifier}})\b'
      scope: entity.name.type.sp
      push:
        - include: comments

        - match: '='
          scope: keyword.operator.assignment.sp
          set: typedef_function

        - match: (?=\S)
          fail: typedef_begin

  typedef_end:
    - match: '(?=\S)'
      pop: true

  typedef_function:
    - include: comments

    - match: '\bfunction\b'
      scope: storage.modifier.sp
      branch_point: typedef_function_begin
      branch:
        - typedef_function_type
        - typedef_end

    - match: (?=\S)
      pop: 2

  typedef_function_type:
    - include: comments

    - match: '\b({{identifier}})\b'
      scope: storage.type.sp
      push:
        - include: comments

        - match: \(
          scope: meta.function.parameters.sp punctuation.section.group.begin.sp
          set:
            - match: \)
              scope: punctuation.section.group.end.sp
              pop: 2

            - include: function-params

        - match: (?=\S)
          fail: typedef_function_begin

  typeset:
    - match: \b(typeset)\b
      scope: keyword.declaration.sp
      branch_point: typeset_begin
      branch:
        - typeset_type
        - typeset_end

  typeset_end:
    - match: '(?=\S)'
      pop: true

  typeset_type:
    - include: comments

    - match: '\b(?:{{identifier}})\b'
      scope: entity.name.type.sp
      push:
        - include: comments
        - match: \{
          scope: punctuation.section.block.begin.sp
          set:
            - meta_scope: meta.block.typeset.sp
            - match: \}
              scope: punctuation.section.block.end.sp
              pop: 2

            - include: comments_documentation
            - include: typeset_function

        - match: (?=\S)
          fail: typeset_begin

  typeset_function:
    - include: comments

    - match: '\bfunction\b'
      scope: storage.modifier.sp
      branch_point: typeset_function_begin
      branch:
        - typeset_function_type
        - typeset_end

    - match: ';'
      scope: punctuation.terminator.sp

  typeset_function_type:
    - include: comments

    - match: (?=\})|[^[:alpha:]_\s]+
      pop: true

    - match: '\bfunction\b'
      fail: typeset_function_begin

    - match: '\b(?:{{identifier}})\b'
      scope: storage.type.sp
      push:
        - include: comments

        - match: \(
          scope: meta.function.parameters.sp punctuation.section.group.begin.sp
          set:
            - match: \)
              scope: punctuation.section.group.end.sp
              pop: 2

            - include: function-params

        - match: (?=\S)
          pop: 2

  function-params:
    - match: (?=\S)
      branch_point: function_param_begin
      branch:
      - function_param_old
      - function_param_new

  function_param_old:
    - match: (?=\))
      pop: true

    - include: comments

    - match: ','
      scope: punctuation.separator.sp
      pop: true

    - match: '&'
      scope: keyword.operator.reference.sp

    - match: \bconst\b\s*
      scope: storage.modifier.sp

    - match: \b({{identifier}})\s*(:)
      captures:
        1: storage.type.sp
        2: punctuation.separator.sp
      push:
        - match: (?=,|\))
          pop: true

        - include: comments
        - include: function_param_old_cont

        - match: '\.\.\.'
          scope: keyword.operator.variadic.c
          set:
            - match: (?=\))
              pop: true

            - include: comments

            - match: '[^\s\)]'
              scope: invalid.illegal.variadic-must-be-end.sp

        - match: '\.{1,2}'

        - match: (\S+)
          scope: invalid.illegal.sp

    - match: (?=\b({{identifier}})\b)
      push: function_param_old_cont

    - match: \S+
      scope: invalid.illegal.sp


  function_param_old_cont:
    - include: comments

    - match: (&\s*)?\b({{identifier}})\b
      captures:
        1: keyword.operator.reference.sp
        2: variable.parameter.sp
      set:
        - match: (?=,|\))
          pop: true

        - include: comments

        - match: '(?=\[)'
          push: brackets

        - match: '='
          scope: keyword.operator.assignment.sp
          set:
            - match: '(?=,|\))'
              pop: true

            - match: \b{{identifier}}\b
              scope: variable.other.constant.sp

            - include: expressions

        - match: '(?=[[:alpha:]_])'
          fail: function_param_begin

        - match: '\.'
          fail: function_param_begin


  function_param_new:
    - match: (?=\))
      pop: true

    - include: comments

    - match: ','
      scope: punctuation.separator.sp
      pop: true

    - match: '\bconst\b'
      scope: storage.modifier.sp

    - match: '\b{{identifier}}\b'
      scope: storage.type.sp
      push:
        - match: (?=,|\))
          pop: true

        - include: comments

        - match: '\.\.\.'
          scope: keyword.operator.variadic.c
          set:
            - match: (?=\))
              pop: true

            - include: comments

            - match: '[^\s\)]'
              scope: invalid.illegal.variadic-must-be-end.sp

        - match: '\.{1,2}'

        - match: '\['
          scope: punctuation.section.brackets.begin.sp
          push:
            - meta_scope: meta.brackets.sp
            - match: \]
              scope: punctuation.section.brackets.end.sp
              pop: true

            - match: (?=,|\))
              pop: 2

            - include: comments

            - match: '[^\s\]]+'
              scope: invalid.illegal.sp

        - match: '&'
          scope: keyword.operator.reference.sp

        - match: '\b{{identifier}}\b'
          scope: variable.parameter.sp
          set:
            - match: (?=,|\))
              pop: true

            - match: (?=\[)
              push: brackets

            - include: comments

            - match: '='
              scope: keyword.operator.assignment.sp
              set:
                - match: '(?=,|\))'
                  pop: true

                - match: \b{{identifier}}\b
                  scope: variable.other.constant.sp

                - include: expressions

            - match: '[^[;&,\)\s]]+'
              scope: invalid.illegal.sp

        - match: '[^[;&,\)\s]]+'
          scope: invalid.illegal.sp

    - match: '[^[;&,\)\s]]+'
      scope: invalid.illegal.sp

  brackets:
    - match: \[
      scope: punctuation.section.brackets.begin.sp
      set:
        - meta_scope: meta.brackets.sp
        - match: \]
          scope: punctuation.section.brackets.end.sp
          pop: true
        - include: expressions-simple

  parens:
    - match: \(
      scope: punctuation.section.group.begin.sp
      push:
        - meta_scope: meta.group.sp
        - match: \)
          scope: punctuation.section.group.end.sp
          pop: true

        - include: expressions

  braces:
    - match: \{
      scope: punctuation.section.braces.begin.sp
      push:
        - meta_scope: meta.block.sp
        - match: \}
          scope: punctuation.section.braces.end.sp
          pop: true

        - include: expressions

  case-default:
    - match: '\bdefault\b'
      scope: keyword.control.sp
      set:
        - match: ':'
          scope: punctuation.separator.sp
          pop: true

        - include: comments

        - match: '^\s*(?=$|\})'
          pop: true

        - match: \s+(?=[^\s:])
          scope: invalid.illegal.missing-comma.sp
          pop: true

    - match: '\bcase\b'
      scope: keyword.control.sp
      set:
        - match: ':'
          scope: punctuation.separator.sp
          pop: true

        - include: expressions-simple

  view_as:
    - match: \b(view_as)\b\s*
      scope: keyword.operator.word.viewas.sp
      push:
        - match: '<'
          scope: punctuation.section.generic.begin.sp
          set:
            - match: '>'
              scope: punctuation.section.generic.end.sp
              pop: true

            - match: '\b(?:{{identifier}})\b'
              scope: storage.type.sp

            # - include: expressions-simple

        - match: (?=\S)
          pop: true


  # types:
  #   - match: '\b({{basic_types}})\b'
  #     scope: support.type.sp
  #   - match: '\bHandle\b'
  #     scope: storage.type.enum.sp
  #   - match: '{{identifier}}:[^:]'
  #     scope: invalid.deprecated.sp


  # https://github.com/alliedmodders/sourcepawn/blob/d919ffc892fb2c908990bd2307e79893bde220a9/compiler/parser.cpp#L1005
  constants:
    - match: '\b(true|false|null|EOS|INVALID_FUNCTION|cellmax|cellmin)\b'
      captures:
        1: constant.language.sp
    - match: \b(__LINE__|__Pawn|debug)\b
      captures:
        1: support.constant.sp
    - match: '{{numerals}}'
      scope: constant.numeric.sp
    - match: '\b[A-Z_][A-Z_\d]+\b'
      scope: variable.constant.sp

  strings:
    - include: const_char

    - match: (?<!\\)(\\\\)*\K\"
      scope: punctuation.definition.string.begin.sp
      set:
        - meta_scope: string.quoted.double.sp
        - match: (?<!\\)(\\\\)*\K\"
          scope: punctuation.definition.string.end.sp
          pop: true
        - match: '{{str_format_char}}'
          scope: constant.other.placeholder.sp
        - match: (?:({{const_char_escape}})|(\\.))
          captures:
            1: constant.character.escape.sp
            2: invalid.illegal.unexpected-character.sp

  const_char:
    - match: (?<!\\)(?:\\\\)*\K(\')(?:([^\\'])|({{const_char_escape}}))?(')
      captures:
        1: punctuation.definition.string.begin.sp
        2: constant.character.sp
        3: constant.character.escape.sp
        4: punctuation.definition.string.end.sp

    - match: (?<!\\)(?:\\{2})*\K(\')([^']+|')?
      captures:
        1: punctuation.definition.string.begin.sp
        2: invalid.illegal.unexpected-character.sp
      set:
        - meta_scope: string.quoted.single.sp
        - match: (?<!\\)(?:\\{2})*\K\'
          scope: punctuation.definition.string.end.sp
          pop: true

  unique-keywords:
    - match: \bbreak\b
      scope: keyword.control.flow.break.sp
    - match: \bcontinue\b
      scope: keyword.control.flow.continue.sp
    - match: \breturn\b
      scope: keyword.control.flow.return.sp
    - match: '\b({{control_keywords}})\b'
      scope: keyword.control.sp
    - match: '\b(?:sizeof|cellsof|tagof)\b'
      scope: keyword.operator.word.sp
    - match: \bdelete|new\b
      scope: keyword.control.sp
    - match: '\bthis\b'
      scope: variable.language

  operators:
    - match: (?:\+\+|--)
      scope: keyword.operator.arithmetic.sp
    - match: \+\=|-\=|\*\=|/\=|%\=|&\=|\|\=|\^\=|>>\=|<<\=
      scope: keyword.operator.assignment.augmented.sp
    - match: <<|>>|&&|\|\|
      scope: keyword.operator.arithmetic.sp
    - match: (?:<|>|\=|!)\=|<|>
      scope: keyword.operator.comparison.sp
    - match: \+|\-|/|%|\||\^|~|!|\*
      scope: keyword.operator.arithmetic.sp
    - match: \=
      scope: keyword.operator.assignment.sp
    - match: '\?|:(?!:)'
      scope: keyword.operator.ternary.sp
    - match: '\.\.\.'
      scope: keyword.operator.variadic.sp

  comments:
    - match: (?<!\\)(\\\\)*\K\/\*
      captures:
        0: punctuation.definition.comment.begin.sp
      push:
        - meta_scope: comment.block.sp
        - match: \*\/
          scope: punctuation.definition.comment.end.sp
          pop: true
        - include: comment_keywords

    - match: '\/\/'
      scope: puncutation.definition.comment
      push:
        - meta_scope: comment.line.sp
        - match: '{{end_of_line}}'
          pop: true
        - match: (?<!\\)(?:\\\\)*\K(\\)$(?=\n)
          scope: punctuation.separator.continuation.sp
        - include: comment_keywords

  comments_documentation:
    - match: '\/\/'
      scope: comment.line.sp puncutation.definition.comment
      embed: sp_comment_doc
      embed_scope: comment.line.sp
      escape: '{{end_of_line}}'

    - match: (?<!\\)(\\\\)*\K\/\*\*
      scope: comment.block.documentation.sp punctuation.definition.comment.begin.sp
      embed: sp_comment_doc
      embed_scope: comment.block.documentation.sp
      escape: \*\/
      escape_captures:
        0: comment.block.documentation.sp punctuation.definition.comment.end.sp

    - match: (?<!\\)(\\\\)*\K\/\*
      scope: comment.block.documentation.sp punctuation.definition.comment.begin.sp
      push:
        - meta_scope: comment.block.sp
        - match: \*\/
          scope: punctuation.definition.comment.end.sp
          pop: true
        - include: comment_keywords

  sp_comment_doc:
    - match: '(@)(deprecated|endsection|error|noreturn|note|return|section)\b'
      captures:
        1: punctuation.definition.keyword.sp
        2: keyword.other.documentation.sp
    - match: (@)(param)\b(?:\s+(\S+))?
      captures:
        1: punctuation.definition.keyword.sp
        2: keyword.other.documentation.param.sp
        3: variable.parameter.sp

    - include: comment_keywords

  comment_keywords:
    - match: '\b(TODO|ToDo|FixMe|FIXME|NOTE|BUG|XXX|HACK|IDEA)\b(?:\s*([-:]))?'
      scope: keyword.other.documentation.note.sp

  # should be near the end?
  # functions:
  #   - match: '^[ \t]*(?:({{modifier_decl}})[ \t]+)?(?:({{deprecated_identifier}})|({{identifier}}))(?<!{{control_keywords}}|public)[ \t]+({{identifier}})[ \t]*(?=\()'
  #     captures:
  #       1: storage.modifier.sp
  #       2: invalid.deprecated.sp
  #       3: storage.type.sp
  #       4: entity.name.function.sp
